// ==UserScript==
// @name         mydealz Bundesweite H√§ndler Highlighter
// @namespace    http://tampermonkey.net/
// @version      2.0
// @description  Hebt bundesweite Deals bestimmter H√§ndler farblich hervor und f√ºgt vordefinierte Meldungs-Texte ein
// @author       You
// @match        https://www.mydealz.de/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=mydealz.de
// @grant        GM_registerMenuCommand
// ==/UserScript==

(function () {
    'use strict';

    // ============================================
    // TIMING & LOGGING
    // ============================================

    function log(message) {
        const now = new Date();
        const timestamp = now.toLocaleString('de-DE', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            fractionalSecondDigits: 3
        });
        console.log(`[${timestamp}] [Bundesweite H√§ndler] ${message}`);
    }

    // Debounce-Funktion: Verz√∂gert die Ausf√ºhrung bis keine neuen Aufrufe mehr kommen
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // ============================================
    // KONFIGURATION
    // ============================================

    const MAX_REPORT_LENGTH = 250; // Maximale Zeichenl√§nge f√ºr mydealz Report-Textfeld

    // H√§ndler-Liste mit zugeh√∂rigen Meldungstexten
    const MERCHANTS = {
        'aldi s√ºd': {
            keywords: ['aldi s√ºd', 'aldi-s√ºd', 'aldis√ºd'],
            displayName: 'Aldi S√ºd',
            expectedRegions: 7, // BW, BY, HE, NW, RP, SL, TH
            validRegions: ['baden-w√ºrttemberg', 'bayern', 'hessen', 'nordrhein-westfalen', 'rheinland-pfalz', 'saarland', 'th√ºringen'],
            reportText: 'Nicht bundesweit. | Aldi S√ºd: Baden-W√ºrttemberg (Stuttgart, Mannheim, Andere) | Bayern (M√ºnchen, N√ºrnberg, Andere) | Hessen (Frankfurt am Main, Andere) | Nordrhein-Westfalen | Andere: Rheinland-Pfalz, Saarland, Th√ºringen',
            reportTextFull: 'Nicht bundesweit. | Aldi S√ºd: Baden-W√ºrttemberg (Stuttgart, Mannheim, Andere) | Bayern (M√ºnchen, N√ºrnberg, Andere) | Hessen (Frankfurt am Main, Andere) | Nordrhein-Westfalen | Andere: Rheinland-Pfalz, Saarland, Th√ºringen'
        },
        'combi': {
            keywords: ['combi', 'combi verbrauchermarkt'],
            displayName: 'Combi',
            expectedRegions: 3, // Bremen, Niedersachsen, NW
            reportText: 'Nicht bundesweit. | Combi: Bremen | Niedersachsen (Hannover, Andere) | Nordrhein-Westfalen (Bielefeld, Andere)',
            reportTextFull: 'Nicht bundesweit. | Combi: Bremen | Niedersachsen (Hannover, Andere) | Nordrhein-Westfalen (Bielefeld, Andere)'
        },
        'finkbeiner': {
            keywords: ['finkbeiner'],
            displayName: 'Finkbeiner',
            expectedRegions: 2, // BW, BY
            reportText: 'Nicht bundesweit. | Finkbeiner: Baden-W√ºrttemberg (Andere) | Bayern (Augsburg, Andere)',
            reportTextFull: 'Nicht bundesweit. | Finkbeiner: Baden-W√ºrttemberg (Andere) | Bayern (Augsburg, Andere)'
        },
        'zimmermann sonderposten': {
            keywords: ['zimmermann sonderposten', 'zimmermann-sonderposten'],
            displayName: 'Zimmermann Sonderposten',
            expectedRegions: 5, // Bremen, HE, NI, NW, ST
            reportText: 'Nicht bundesweit. | Zimmermann Sonderposten: Bremen | Hessen (Wiesbaden, Andere) | Niedersachsen (Hannover, Braunschweig, Andere) | Nordrhein-Westfalen (Andere) | Sachsen-Anhalt (Magdeburg, Andere)',
            reportTextFull: 'Nicht bundesweit. | Zimmermann Sonderposten: Bremen | Hessen (Wiesbaden, Andere) | Niedersachsen (Hannover, Braunschweig, Andere) | Nordrhein-Westfalen (Andere) | Sachsen-Anhalt (Magdeburg, Andere)'
        },
        'netto': {
            keywords: ['netto'],
            merchantId: '2977', // Nur Netto mit dem Scottie (nicht Netto Marken-Discount mit ID 739)
            displayName: 'Netto',
            expectedRegions: 7, // BE, BB, MV, NI, SN, ST, SH
            reportText: 'Nicht bundesweit. | Netto mit dem Scottie: Berlin | Brandenburg | Mecklenburg-Vorpommern | Niedersachsen (Andere) | Sachsen | Sachsen-Anhalt | Schleswig-Holstein',
            reportTextFull: 'Nicht bundesweit. | Netto mit dem Scottie: Berlin | Brandenburg | Mecklenburg-Vorpommern | Niedersachsen (Andere) | Sachsen | Sachsen-Anhalt | Schleswig-Holstein'
        },
        'b1 discount baumarkt': {
            keywords: ['b1 discount baumarkt'],
            displayName: 'B1 Discount Baumarkt',
            expectedRegions: 7, // BW, HE, MV, NW, SH, SN, ST, TH
            reportText: 'Nicht bundesweit. | B1 Discount Baumarkt: NW (Bielefeld, Andere) | SH (Kiel, Andere) | TH (Erfurt, Andere) | Andere: Baden-W√ºrttemberg, Hessen, Mecklenburg-Vorpommern, Sachsen, Sachsen-Anhalt',
            reportTextFull: 'Nicht bundesweit. | B1 Discount Baumarkt: Nordrhein-Westfalen (Bielefeld, Andere) | Schleswig-Holstein (Kiel, Andere) | Th√ºringen (Erfurt, Andere) | Andere: Baden-W√ºrttemberg, Hessen, Mecklenburg-Vorpommern, Sachsen, Sachsen-Anhalt'
        },
        'xxxlutz': {
            keywords: ['xxxlutz', 'xxx lutz', 'xxxl lutz'],
            displayName: 'XXXLutz',
            expectedRegions: 8, // BW, BY, HE, MV, NI, NW, RP, SH, TH
            reportText: 'Nicht bundesweit. | XXXLutz: BW (Karlsruhe, Mannheim, Andere) | BY (Augsburg, N√ºrnberg, Andere) | HE (Wiesbaden, Andere) | NI (Braunschweig, Hannover, Andere) | NW (Essen, Andere) | Andere: RP, SH, TH, MV',
            reportTextFull: 'Nicht bundesweit. | XXXLutz: Baden-W√ºrttemberg (Karlsruhe, Mannheim, Andere) | Bayern (Augsburg, N√ºrnberg, Andere) | Hessen (Wiesbaden, Andere) | Niedersachsen (Braunschweig, Hannover, Andere) | Nordrhein-Westfalen (Essen, Andere) | Andere: Rheinland-Pfalz, Schleswig-Holstein, Th√ºringen, Mecklenburg-Vorpommern'
        }
        ,
        'aldi nord': {
            keywords: ['aldi nord', 'aldi-nord', 'aldinord'],
            displayName: 'Aldi Nord',
            expectedRegions: 12, // 10 Bundesl√§nder + 2x Andere (f√ºr Hessen + NW)
            validRegions: ['berlin', 'brandenburg', 'bremen', 'hamburg', 'mecklenburg-vorpommern', 'niedersachsen', 'sachsen', 'sachsen-anhalt', 'schleswig-holstein', 'th√ºringen', 'andere', 'andere'], // NUR die 10 BL die mydealz einzeln auflistet + 2x "andere" f√ºr Hessen + NW
            reportText: 'Nicht bundesweit. | Aldi Nord: Berlin | Brandenburg | Bremen | Hamburg | Hessen (A) | MV | Niedersachsen | NW (Bielefeld, Bochum, Dortmund, Essen, Gelsenkirchen, M√ºnster, Wuppertal, A) | Sachsen | Sachsen-Anhalt | Schleswig-Holstein | Th√ºringen',
            reportTextFull: 'Nicht bundesweit. | Aldi Nord: Berlin | Brandenburg | Bremen | Hamburg | Hessen (Andere) | Mecklenburg-Vorpommern | Niedersachsen | Nordrhein-Westfalen (Bielefeld, Bochum, Dortmund, Essen, Gelsenkirchen, M√ºnster, Wuppertal, Andere) | Sachsen | Sachsen-Anhalt | Schleswig-Holstein | Th√ºringen'
        },
        'globus baumarkt': {
            keywords: ['globus baumarkt', 'globus-baumarkt'],
            merchantId: '309', // Globus Baumarkt (Heimwerkermarkt)
            displayName: 'Globus Baumarkt',
            expectedRegions: 14, // BW, BY, BE, BB, HE, MV, NI, NW, RP, SL, SN, ST, SH, TH
            validRegions: ['baden-w√ºrttemberg', 'bayern', 'berlin', 'brandenburg', 'hessen', 'mecklenburg-vorpommern', 'niedersachsen', 'nordrhein-westfalen', 'rheinland-pfalz', 'saarland', 'sachsen', 'sachsen-anhalt', 'schleswig-holstein', 'th√ºringen'],
            reportText: 'Nicht bundesweit. | Globus Baumarkt: Berlin | Niedersachsen (Andere) | Saarland | Sachsen (Andere) | Sachsen-Anhalt (Andere) | Schleswig-Holstein (Andere) | Andere: BW, Bayern, Brandenburg, Hessen, MV, NW, RP, Th√ºringen',
            reportTextFull: 'Nicht bundesweit. | Globus Baumarkt: Berlin | Niedersachsen (Andere) | Saarland | Sachsen (Andere) | Sachsen-Anhalt (Andere) | Schleswig-Holstein (Andere) | Andere: Baden-W√ºrttemberg, Bayern, Brandenburg, Hessen, Mecklenburg-Vorpommern, Nordrhein-Westfalen, Rheinland-Pfalz, Th√ºringen'
        },
        'globus': {
            keywords: ['globus sb-warenhaus', 'globus markt'],
            merchantId: '124', // GLOBUS Lebensmittel (SB-Warenhaus)
            displayName: 'GLOBUS',
            expectedRegions: 12, // BW, BY, HH, HE, MV, NI, NW, RP, SL, SN, ST, TH
            validRegions: ['baden-w√ºrttemberg', 'bayern', 'hamburg', 'hessen', 'mecklenburg-vorpommern', 'niedersachsen', 'nordrhein-westfalen', 'rheinland-pfalz', 'saarland', 'sachsen', 'sachsen-anhalt', 'th√ºringen'],
            reportText: 'Nicht bundesweit. | GLOBUS: Hamburg | Niedersachsen (Andere) | Saarland | Sachsen (Andere) | Sachsen-Anhalt (Andere) | Andere: BW, Bayern, Hessen, MV, NW, RP, Th√ºringen',
            reportTextFull: 'Nicht bundesweit. | GLOBUS: Hamburg | Niedersachsen (Andere) | Saarland | Sachsen (Andere) | Sachsen-Anhalt (Andere) | Andere: Baden-W√ºrttemberg, Bayern, Hessen, Mecklenburg-Vorpommern, Nordrhein-Westfalen, Rheinland-Pfalz, Th√ºringen'
        },
        'nah und gut': {
            keywords: ['nah und gut', 'nah & gut', 'nahundgut'],
            displayName: 'Nah und Gut',
            expectedRegions: 10, // BW, BY, BE, HE, NI, NW, RP, SN, SL, TH
            reportText: 'Nicht bundesweit. | Nah und Gut: BW (Karlsruhe, Mannheim, Stuttgart, A) | BY (Augsburg, M√ºnchen, N√ºrnberg, A) | BE | HE (Frankfurt, Wiesbaden, A) | NI (BS, A) | NW (D√ºsseldorf, Duisburg, M√ºnster, A) | RP (A) | SN (C, DD, L, A) | SL (SB, A) | TH (A)',
            reportTextFull: 'Nicht bundesweit. | Nah und Gut: Baden-W√ºrttemberg (Karlsruhe, Mannheim, Stuttgart, Andere) | Bayern (Augsburg, M√ºnchen, N√ºrnberg, Andere) | Berlin | Hessen (Frankfurt am Main, Wiesbaden, Andere) | Niedersachsen (Braunschweig, Andere) | Nordrhein-Westfalen (D√ºsseldorf, Duisburg, M√ºnster, Andere) | Rheinland-Pfalz (Andere) | Sachsen (Chemnitz, Dresden, Leipzig, Andere) | Saarland (Saarbr√ºcken, Andere) | Th√ºringen (Andere)'
        }
    };

    const HIGHLIGHT_COLOR = '#ff6b35'; // Orange-Rot f√ºr nicht-bundesweite H√§ndler
    const HIGHLIGHT_COLOR_BUNDESWEIT = '#28a745'; // Gr√ºn f√ºr bundesweite H√§ndler
    const HIGHLIGHT_WIDTH = '3px';

    // Liste bundesweiter H√§ndler (werden gr√ºn hervorgehoben)
    const BUNDESWEITE_HAENDLER = [];

    // ============================================
    // VALIDIERUNG DER KONFIGURATION
    // ============================================

    // Pr√ºfe alle H√§ndler-Texte beim Script-Start
    (function validateMerchantTexts() {
        for (const [merchantName, config] of Object.entries(MERCHANTS)) {
            const textLength = config.reportText?.length || 0;

            if (textLength > MAX_REPORT_LENGTH) {
                console.error(`‚ùå [Bundesweite H√§ndler] FEHLER: ${merchantName} - reportText zu lang: ${textLength}/${MAX_REPORT_LENGTH} Zeichen`);
                console.error(`   Text: "${config.reportText}"`);
            } else {
                console.log(`‚úì [Bundesweite H√§ndler] ${merchantName} - reportText: ${textLength}/${MAX_REPORT_LENGTH} Zeichen`);
            }
        }
    })();

    // ============================================
    // DEAL HIGHLIGHTING
    // ============================================

    function normalizeText(text) {
        return text.toLowerCase().trim().normalize('NFKC');
    }

    function checkIfMerchantMatch(dealElement) {
        // Pr√ºfe Titel
        const titleElement = dealElement.querySelector('.thread-title a, .js-thread-title');
        const title = titleElement ? normalizeText(titleElement.textContent) : '';

        // Pr√ºfe Merchant Link
        const merchantLink = dealElement.querySelector('[data-t="merchantLink"]');
        const merchantText = merchantLink ? normalizeText(merchantLink.textContent) : '';

        // Extrahiere merchant-id aus dem Link (falls vorhanden)
        let merchantId = null;
        if (merchantLink && merchantLink.href) {
            try {
                const url = new URL(merchantLink.href);
                merchantId = url.searchParams.get('merchant-id');
                log(`Debug - Deal ${dealElement.id}: merchant-id="${merchantId}", merchantText="${merchantText}"`);
            } catch (e) {
                // Falls URL-Parsing fehlschl√§gt, ignoriere
                log(`Debug - Deal ${dealElement.id}: URL-Parsing fehlgeschlagen f√ºr ${merchantLink.href}`);
            }
        } else {
            log(`Debug - Deal ${dealElement.id}: Kein merchantLink gefunden`);
        }

        // Pr√ºfe gegen alle konfigurierten H√§ndler
        for (const [merchantName, config] of Object.entries(MERCHANTS)) {
            // Wenn eine merchantId konfiguriert ist, pr√ºfe diese zuerst (pr√§ziser)
            if (config.merchantId && merchantId) {
                if (merchantId === config.merchantId) {
                    log(`Debug - Match via merchantId: ${merchantName} (${merchantId})`);
                    return merchantName;
                }
                // Wenn merchantId nicht √ºbereinstimmt, √ºberspringe diesen H√§ndler
                continue;
            }

            // Fallback: Pr√ºfe Keywords NUR im Merchant-Text (NICHT im Titel!)
            for (const keyword of config.keywords) {
                if (merchantText.includes(keyword)) {
                    log(`Debug - Match via Keyword "${keyword}" in merchantText: ${merchantText}`);
                    return merchantName;
                }
            }
        }
        return null;
    }

    function checkIfBundesweit(dealElement) {
        log(`Debug - checkIfBundesweit f√ºr Deal ${dealElement.id}`);

        // Pr√ºfe 1: Location-Icon-Bereich (f√ºr "Bundesweit" oder "offline")
        const locationDiv = dealElement.querySelector('.icon--location')?.closest('div');
        if (locationDiv) {
            const locationText = normalizeText(locationDiv.textContent);
            log(`Debug - locationDiv gefunden, Text: "${locationText}"`);

            // Fall 1: Explizit "Bundesweit"
            if (locationText.includes('bundesweit')) {
                log(`Debug - "bundesweit" gefunden ‚Üí return true`);
                return true;
            }

            // Fall 2: Hat "offline" ‚Üí ist lokal beschr√§nkt
            if (locationText.includes('offline')) {
                log(`Debug - "offline" gefunden ‚Üí return false`);
                return false;
            }
        } else {
            log(`Debug - Kein locationDiv gefunden`);
        }

        // Pr√ºfe 2: Merchant-Link-Bereich (falls kein Location-Icon)
        const merchantLinkSpan = dealElement.querySelector('[data-t="merchantLink"]')?.closest('span.color--text-TranslucentSecondary');
        if (merchantLinkSpan) {
            const text = normalizeText(merchantLinkSpan.textContent);
            log(`Debug - merchantLinkSpan gefunden, Text: "${text}"`);

            // Kein "offline" vorhanden ‚Üí faktisch bundesweit
            if (!text.includes('offline')) {
                log(`Debug - merchantLinkSpan ohne "offline" gefunden ‚Üí return true`);
                return true;
            } else {
                log(`Debug - merchantLinkSpan mit "offline" ‚Üí return false`);
                return false;
            }
        } else {
            log(`Debug - Kein merchantLinkSpan gefunden`);
        }

        log(`Debug - Keine Kriterien erf√ºllt ‚Üí return false`);
        return false;
    }

    function highlightDeal(dealElement, merchantName, isBundesweitMerchant = false) {
        // Verhindere doppeltes Highlighting
        if (dealElement.hasAttribute('data-highlighted-deal')) {
            log(`‚ö† Deal bereits markiert, √ºberspringe: ${dealElement.id}`);
            return;
        }
        dealElement.setAttribute('data-highlighted-deal', 'true');

        // Finde die Card (threadListCard)
        const card = dealElement.querySelector('.threadListCard');
        if (!card) {
            log(`‚ö† Keine .threadListCard gefunden f√ºr: ${dealElement.id}`);
            return;
        }

        // W√§hle Farbe basierend auf H√§ndler-Typ
        const color = isBundesweitMerchant ? HIGHLIGHT_COLOR_BUNDESWEIT : HIGHLIGHT_COLOR;
        const typ = isBundesweitMerchant ? 'bundesweit (gr√ºn)' : 'regional (rot)';

        // Setze farblichen Rahmen
        card.style.border = `${HIGHLIGHT_WIDTH} solid ${color}`;
        card.style.boxShadow = `0 0 10px ${color}40`;
        card.style.borderRadius = '8px';

        // Speichere H√§ndler-Info f√ºr sp√§tere Verwendung
        dealElement.setAttribute('data-merchant-highlight', merchantName);
        dealElement.setAttribute('data-merchant-bundesweit', isBundesweitMerchant);

        log(`‚úì Deal hervorgehoben: ${merchantName} (${typ}) (ID: ${dealElement.id})`);
    }

    let lastProcessedCount = 0;

    function processDeals() {
        const dealElements = document.querySelectorAll('.thread:not([data-highlighted-deal])');

        // Early Exit: Keine neuen Deals
        if (dealElements.length === 0 && lastProcessedCount === 0) {
            return;
        }

        if (dealElements.length > 0) {
            log(`Verarbeite ${dealElements.length} neue Deals`);
        }

        lastProcessedCount = document.querySelectorAll('.thread').length;

        dealElements.forEach(dealElement => {
            const merchantName = checkIfMerchantMatch(dealElement);
            if (!merchantName) return;

            const isBundesweit = checkIfBundesweit(dealElement);
            const isBundesweitMerchant = BUNDESWEITE_HAENDLER.includes(merchantName.toLowerCase());

            log(`Deal gefunden: H√§ndler="${merchantName}", Bundesweit-Tag=${isBundesweit}, Bundesweiter-H√§ndler=${isBundesweitMerchant}`);

            // Gr√ºn markieren: Bundesweite H√§ndler MIT "Bundesweit"-Tag
            if (isBundesweitMerchant && isBundesweit) {
                log(`‚úì Bundesweiter H√§ndler korrekt markiert (gr√ºn)`);
                highlightDeal(dealElement, merchantName, true);
                return;
            }

            // Rot markieren: Regionale H√§ndler MIT "Bundesweit"-Tag (falsch!)
            if (!isBundesweitMerchant && isBundesweit) {
                log(`‚ö† Regionaler H√§ndler falsch als bundesweit markiert (rot)`);
                highlightDeal(dealElement, merchantName, false);
                return;
            }

            // Keine Markierung: Alle anderen F√§lle
            log(`‚Üí Deal √ºbersprungen (kein Bundesweit-Tag oder korrekter H√§ndler)`);
        });
    }

    // ============================================
    // AUTO-FILL REPORT TEXT
    // ============================================

    function getCurrentMerchant() {
        // Pr√ºfe ob wir auf einer Deal-Seite sind
        const dealElement = document.querySelector('.thread');
        if (!dealElement) return null;

        return checkIfMerchantMatch(dealElement);
    }

    function fillReportTextarea(merchantName) {
        if (!MERCHANTS[merchantName]) {
            log(`Kein H√§ndler gefunden: ${merchantName}`);
            return false;
        }

        const merchant = MERCHANTS[merchantName];
        const reportText = merchant.reportText;

        // Validierung: Text darf nicht zu lang sein
        if (reportText.length > MAX_REPORT_LENGTH) {
            log(`‚ùå FEHLER: Text f√ºr ${merchantName} √ºberschreitet ${MAX_REPORT_LENGTH} Zeichen!`);
            log(`   reportText: ${reportText.length} Zeichen`);
            log(`   Bitte Konfiguration korrigieren!`);
            return false;
        }

        log(`Text-L√§nge OK: ${reportText.length}/${MAX_REPORT_LENGTH} Zeichen`);

        // WICHTIG: Pr√ºfe, ob "Eingeschr√§nktes / zielgerichtetes Angebot" ausgew√§hlt ist
        if (!isRestrictedOfferSelected()) {
            log(`‚ö† "Eingeschr√§nktes Angebot" nicht ausgew√§hlt, Text wird NICHT eingef√ºgt`);
            return false;
        }

        // Suche nach dem Report-Textfeld (mit ID "report-entry" oder im Report-Formular)
        const textareas = document.querySelectorAll('textarea[id^="report-entry"], [data-t="reportForm"] textarea, textarea.input');

        log(`Gefundene Textareas: ${textareas.length}`);

        for (const textarea of textareas) {
            // Pr√ºfe ob Textfeld sichtbar ist
            if (textarea.offsetParent === null) {
                log('Textarea nicht sichtbar, √ºberspringe');
                continue;
            }

            // Pr√ºfe Placeholder oder Label
            const placeholder = textarea.getAttribute('placeholder') || '';
            const id = textarea.getAttribute('id') || '';

            log(`Pr√ºfe Textarea - ID: ${id}, Placeholder: ${placeholder}`);

            // Finde das richtige Textfeld
            if (placeholder.includes('Grund') || id.startsWith('report-entry')) {
                textarea.value = reportText;

                // Trigger events
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                textarea.dispatchEvent(new Event('change', { bubbles: true }));
                textarea.dispatchEvent(new Event('blur', { bubbles: true }));

                log(`‚úì Auto-Text eingef√ºgt f√ºr: ${merchantName}`);
                return true;
            }
        }

        log('Kein passendes Textfeld gefunden');
        return false;
    }

    function isRestrictedOfferSelected() {
        // Suche nach dem "Eingeschr√§nktes / zielgerichtetes Angebot" Radio-Button
        const radioButtons = document.querySelectorAll('input[type="radio"][name="report_reason"]');

        for (const radio of radioButtons) {
            // Pr√ºfe ob dieser Radio-Button den Text "Eingeschr√§nktes" enth√§lt
            const label = radio.closest('label');
            if (label && label.textContent.includes('Eingeschr√§nktes')) {
                log(`Debug - isRestrictedOfferSelected: Gefunden=${radio.checked}`);
                return radio.checked;
            }
        }

        log(`Debug - isRestrictedOfferSelected: Nicht gefunden`);
        return false;
    }

    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            log(`‚úì Text in Zwischenablage kopiert: ${text.substring(0, 50)}...`);
        }).catch((err) => {
            log(`‚ùå Fehler beim Kopieren: ${err}`);
        });
    }

    function createMerchantCopyButton() {
        // Entferne evtl. existierenden Button
        const existingButton = document.getElementById('merchant-copy-button-container');
        if (existingButton) {
            existingButton.remove();
        }

        // Container f√ºr Button
        const container = document.createElement('div');
        container.id = 'merchant-copy-button-container';
        container.style.cssText = `
            margin: 15px 0;
            padding: 10px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
        `;

        // Dropdown f√ºr H√§ndler
        const select = document.createElement('select');
        select.id = 'merchant-copy-select';
        select.style.cssText = `
            padding: 8px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 14px;
            cursor: pointer;
        `;

        // Default Option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'üìã H√§ndler ausw√§hlen f√ºr Copy...';
        select.appendChild(defaultOption);

        // Alle H√§ndler hinzuf√ºgen (alphabetisch sortiert nach displayName)
        const sortedMerchants = Object.keys(MERCHANTS).sort((a, b) => {
            return MERCHANTS[a].displayName.localeCompare(MERCHANTS[b].displayName);
        });

        sortedMerchants.forEach((merchantName) => {
            const option = document.createElement('option');
            option.value = merchantName;
            option.textContent = MERCHANTS[merchantName].displayName;
            select.appendChild(option);
        });

        // Copy Button
        const copyButton = document.createElement('button');
        copyButton.id = 'merchant-copy-button';
        copyButton.textContent = 'üìã Kopieren & Einf√ºgen';
        copyButton.style.cssText = `
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.3s;
        `;

        copyButton.onmouseover = () => { copyButton.style.background = '#0056b3'; };
        copyButton.onmouseout = () => { copyButton.style.background = '#007bff'; };

        copyButton.onclick = () => {
            const selectedMerchant = select.value;
            if (!selectedMerchant) {
                log('‚ö† Kein H√§ndler ausgew√§hlt');
                return;
            }

            const reportText = MERCHANTS[selectedMerchant].reportText;

            // Kopiere in Zwischenablage
            copyToClipboard(reportText);

            // Versuche auch direkt ins Textarea einzuf√ºgen (wenn sichtbar)
            const textarea = document.querySelector('textarea[id^="report-entry"], [data-t="reportForm"] textarea, textarea');
            if (textarea && textarea.offsetParent !== null) {
                textarea.value = reportText;
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                textarea.dispatchEvent(new Event('change', { bubbles: true }));
                log(`‚úì Text eingef√ºgt & kopiert f√ºr: ${selectedMerchant}`);
            } else {
                log(`‚úì Text in Zwischenablage kopiert (Textarea nicht sichtbar)`);
            }
        };

        container.appendChild(select);
        container.appendChild(copyButton);

        // Suche gezielter nach dem Textarea-Container
        const textarea = document.querySelector('textarea[id^="report-entry"], [data-t="reportForm"] textarea, textarea');

        if (textarea) {
            // Finde das √ºbergeordnete Formular oder Container-Element
            let insertTarget = textarea.closest('form') || textarea.closest('div[class*="form"]') || textarea.parentElement;

            // F√ºge Button VOR dem Textarea ein
            if (insertTarget) {
                insertTarget.insertBefore(container, textarea);
                log('‚úì Copy-Button vor Textarea eingef√ºgt');
                return;
            }
        }

        // Fallback: Suche nach Report-Formular
        const reportForm = document.querySelector('[data-t="reportForm"]') || document.querySelector('form[id*="report"]') || document.querySelector('form');
        if (reportForm) {
            reportForm.insertBefore(container, reportForm.firstChild);
            log('‚úì Copy-Button am Anfang des Formulars eingef√ºgt');
        } else {
            // Letzter Fallback: Vor dem ersten Textarea im Dokument
            const anyTextarea = document.querySelector('textarea');
            if (anyTextarea && anyTextarea.parentElement) {
                anyTextarea.parentElement.insertBefore(container, anyTextarea);
                log('‚úì Copy-Button vor erstem Textarea eingef√ºgt');
            } else {
                document.body.appendChild(container);
                log('‚ö† Copy-Button ans body angef√ºgt (kein besserer Ort gefunden)');
            }
        }
    }

    function observeReportForm() {
        let textareaFilled = false;
        let checkCount = 0;

        // √úberwache √Ñnderungen am DOM f√ºr das Melde-Formular
        const observer = new MutationObserver((mutations) => {
            // Verhindere mehrfaches Einf√ºgen
            if (textareaFilled) return;

            // Pr√ºfe ob die Mutation ein Textarea betrifft
            let hasRelevantChange = false;
            for (const mutation of mutations) {
                // Pr√ºfe hinzugef√ºgte Nodes
                for (const node of mutation.addedNodes) {
                    if (node.nodeType === 1) { // Element node
                        // Pr√ºfe ob das Node selbst ein Textarea ist oder eins enth√§lt
                        if (node.tagName === 'TEXTAREA' || node.querySelector('textarea')) {
                            hasRelevantChange = true;
                            break;
                        }
                    }
                }
                if (hasRelevantChange) break;
            }

            // √úberspringe irrelevante √Ñnderungen
            if (!hasRelevantChange) return;

            checkCount++;
            log(`Relevante DOM-√Ñnderung erkannt (Check ${checkCount})`);

            // Suche nach dem Textfeld
            const textarea = document.querySelector('textarea[id^="report-entry"], [data-t="reportForm"] textarea');

            if (!textarea) {
                log('Textarea noch nicht im DOM');
                return;
            }

            // Pr√ºfe ob Textfeld sichtbar ist
            if (textarea.offsetParent === null) {
                log('Textarea gefunden aber nicht sichtbar');
                return;
            }

            const merchantName = getCurrentMerchant();
            if (!merchantName) {
                log('Kein H√§ndler erkannt');
                observer.disconnect();
                return;
            }

            log(`‚úì Sichtbares Textarea gefunden! H√§ndler: ${merchantName}`);

            // Sofort einf√ºgen
            const filled = fillReportTextarea(merchantName);

            if (filled) {
                textareaFilled = true;
                observer.disconnect();
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        log('Observer gestartet, warte auf Textarea...');
    }

    // ============================================
    // URL MONITORING
    // ============================================

    function handleReportPage() {
        log('handleReportPage aufgerufen');

        // Pr√ºfe ob Report-Formular/Modal sichtbar ist (nicht URL-basiert, da Popup)
        const checkForReportModal = () => {
            const reportForm = document.querySelector('[data-t="reportForm"]') ||
                              document.querySelector('form[id*="report"]') ||
                              document.querySelector('[role="dialog"] form') ||
                              document.querySelector('.modal form');

            const textarea = document.querySelector('textarea[id^="report-entry"], [data-t="reportForm"] textarea, textarea[placeholder*="Grund"]');

            log(`Debug - Report-Modal-Check: reportForm=${!!reportForm}, textarea=${!!textarea}`);

            // Nur wenn wirklich ein Report-Formular oder Textarea sichtbar ist
            if (!reportForm && !textarea) {
                log('‚ö† Kein Report-Formular/Textarea gefunden, √ºberspringe');
                return false;
            }

            return true;
        };

        const merchantName = getCurrentMerchant();
        if (!merchantName) {
            log('‚ö† Kein relevanter H√§ndler erkannt - Copy-Button verf√ºgbar f√ºr manuelle Auswahl');
        } else {
            log(`‚úì H√§ndler erkannt: ${merchantName} - versuche Auto-Fill...`);
            // Beobachte DOM-√Ñnderungen (wichtig: wird beim Klick auf "Weiter" aktiv)
            observeReportForm();
        }

        // Erstelle Copy-Button mit Observer (wartet bis Report-Modal/Textarea verf√ºgbar ist)
        const buttonObserver = new MutationObserver((mutations) => {
            // Pr√ºfe ob Button bereits existiert
            if (document.getElementById('merchant-copy-button-container')) {
                return;
            }

            const textarea = document.querySelector('textarea[id^="report-entry"], [data-t="reportForm"] textarea, textarea[placeholder*="Grund"]');
            const reportForm = document.querySelector('[data-t="reportForm"]') ||
                              document.querySelector('form[id*="report"]') ||
                              document.querySelector('[role="dialog"] form') ||
                              document.querySelector('.modal form');

            log(`Debug - buttonObserver: textarea=${!!textarea}, reportForm=${!!reportForm}`);

            // Nur wenn Report-Formular oder Textarea sichtbar ist
            if (textarea || reportForm) {
                log('‚úì Report-Formular/Textarea gefunden, erstelle Copy-Button');
                createMerchantCopyButton();
                buttonObserver.disconnect();
            }
        });

        // Sofort pr√ºfen
        if (checkForReportModal()) {
            log('‚úì Report-Modal sofort erkannt, erstelle Copy-Button');
            setTimeout(() => createMerchantCopyButton(), 300); // Kurze Verz√∂gerung f√ºr vollst√§ndiges Rendering
        } else {
            // Warte auf Report-Modal
            log('‚è≥ Warte auf Report-Modal...');
            buttonObserver.observe(document.body, {
                childList: true,
                subtree: true
            });

            // Timeout nach 10 Sekunden
            setTimeout(() => {
                buttonObserver.disconnect();
                log('‚è± Observer-Timeout nach 10 Sekunden');
            }, 10000);
        }
    }

    // ============================================
    // KONTEXTMEN√ú F√úR COPY & PASTE (Tampermonkey Menu)
    // ============================================

    function showHaendlerMenu() {
        // Entferne evtl. existierendes Men√º
        const existingMenu = document.getElementById('haendler-popup-menu');
        if (existingMenu) {
            existingMenu.remove();
            return; // Toggle: Beim zweiten Klick schlie√üen
        }

        // Erstelle Popup-Men√º
        const menu = document.createElement('div');
        menu.id = 'haendler-popup-menu';
        menu.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-height: 80vh;
            background: white;
            border: 2px solid #007bff;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            z-index: 10001;
            overflow: hidden;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            background: #007bff;
            color: white;
            padding: 12px;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        `;
        header.innerHTML = `
            <span>üìã H√§ndler-Meldungen kopieren</span>
            <button id="close-haendler-menu" style="background: transparent; border: none; color: white; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px;">√ó</button>
        `;

        // Content
        const content = document.createElement('div');
        content.style.cssText = `
            padding: 15px;
            max-height: calc(80vh - 50px);
            overflow-y: auto;
        `;

        // Sortiere H√§ndler alphabetisch
        const sortedMerchants = Object.keys(MERCHANTS).sort((a, b) => {
            return MERCHANTS[a].displayName.localeCompare(MERCHANTS[b].displayName);
        });

        sortedMerchants.forEach(merchantKey => {
            const merchant = MERCHANTS[merchantKey];

            const merchantDiv = document.createElement('div');
            merchantDiv.style.cssText = `
                margin-bottom: 12px;
                padding: 10px;
                background: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
            `;

            merchantDiv.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px; color: #333; font-size: 14px;">${merchant.displayName}</div>
                <div style="display: flex; gap: 8px;">
                    <button class="copy-short-btn" data-merchant="${merchantKey}" style="
                        flex: 1;
                        padding: 6px 10px;
                        background: #28a745;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                        transition: background 0.3s;
                    ">üìã Kurz (${merchant.reportText.length})</button>
                    <button class="copy-full-btn" data-merchant="${merchantKey}" style="
                        flex: 1;
                        padding: 6px 10px;
                        background: #007bff;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                        transition: background 0.3s;
                    ">üìã Lang (${merchant.reportTextFull.length})</button>
                </div>
            `;

            content.appendChild(merchantDiv);
        });

        menu.appendChild(header);
        menu.appendChild(content);
        document.body.appendChild(menu);

        // Event Listeners
        document.getElementById('close-haendler-menu').onclick = () => {
            menu.remove();
        };

        // Copy-Button Handlers
        content.querySelectorAll('.copy-short-btn').forEach(btn => {
            btn.onmouseover = () => { btn.style.background = '#218838'; };
            btn.onmouseout = () => { btn.style.background = '#28a745'; };
            btn.onclick = (e) => {
                const merchantKey = e.target.getAttribute('data-merchant');
                const text = MERCHANTS[merchantKey].reportText;
                copyToClipboard(text);

                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úì Kopiert!';
                btn.style.background = '#155724';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '#28a745';
                }, 2000);
            };
        });

        content.querySelectorAll('.copy-full-btn').forEach(btn => {
            btn.onmouseover = () => { btn.style.background = '#0056b3'; };
            btn.onmouseout = () => { btn.style.background = '#007bff'; };
            btn.onclick = (e) => {
                const merchantKey = e.target.getAttribute('data-merchant');
                const text = MERCHANTS[merchantKey].reportTextFull;
                copyToClipboard(text);

                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úì Kopiert!';
                btn.style.background = '#004085';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '#007bff';
                }, 2000);
            };
        });

        // Schlie√üe beim Klick au√üerhalb
        setTimeout(() => {
            document.addEventListener('click', function closeOnClickOutside(e) {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeOnClickOutside);
                }
            });
        }, 100);

        log('‚úì H√§ndler-Men√º angezeigt');
    }

    // ============================================
    // REGION VALIDATION
    // ============================================

    function normalizeRegionName(name) {
        return name.toLowerCase().trim().normalize('NFKC');
    }

    function validateRegionCount() {
        // Pr√ºfe ob wir auf einer Deal-Detailseite sind
        const dealElement = document.querySelector('.thread');
        if (!dealElement) {
            log('Keine Deal-Detailseite erkannt');
            return;
        }

        // Pr√ºfe ob es ein relevanter H√§ndler ist
        const merchantName = checkIfMerchantMatch(dealElement);
        if (!merchantName) {
            log('Kein konfigurierter H√§ndler erkannt f√ºr Region-Validierung');
            return;
        }

        const merchant = MERCHANTS[merchantName];
        if (!merchant || merchant.expectedRegions === null) {
            log(`H√§ndler "${merchantName}" hat keine Region-Validierung konfiguriert`);
            return;
        }

        // Suche nach dem "X Regionen" Element
        const regionSpan = Array.from(document.querySelectorAll('span.linkPlain.color--text-AccentBrand.text--b'))
            .find(span => /\d+\s+Regionen?/.test(span.textContent));

        if (!regionSpan) {
            log('Kein "X Regionen" Element gefunden');
            return;
        }

        // Extrahiere die Anzahl
        const match = regionSpan.textContent.match(/(\d+)\s+Regionen?/);
        if (!match) {
            log('Konnte Region-Anzahl nicht extrahieren');
            return;
        }

        const actualRegions = parseInt(match[1], 10);
        const expectedRegions = merchant.expectedRegions;

        log(`Region-Validierung: ${merchantName} - Link-Text zeigt: ${actualRegions} Regionen, Erwartet: ${expectedRegions}`);

        // SOFORT Icon setzen: Vergleiche Link-Text-Zahl mit expectedRegions
        const isCorrect = (actualRegions === expectedRegions);
        updateValidationIcon(regionSpan, actualRegions, expectedRegions, isCorrect);

        // Erweiterte Validierung: Pr√ºfe Popup-Inhalt (f√ºr rot/gelb Markierungen, √§ndert NICHT das Icon!)
        setupPopupValidation(regionSpan, merchant, actualRegions, expectedRegions);
    }

    function updateValidationIcon(regionSpan, actualCount, expectedCount, isCorrect) {
        // Entferne evtl. existierendes Icon
        const existingIcon = regionSpan.querySelector('.region-validation-icon');
        if (existingIcon) {
            existingIcon.remove();
        }

        // Erstelle Icon
        const icon = document.createElement('span');
        icon.className = 'region-validation-icon';
        icon.style.cssText = `
            margin-left: 6px;
            font-size: 16px;
            vertical-align: middle;
        `;

        icon.title = isCorrect
            ? `‚úì Korrekt: ${expectedCount} Regionen`
            : `‚úó Falsch: Erwartet ${expectedCount}, gefunden ${actualCount}`;

        icon.textContent = isCorrect ? '‚úÖ' : '‚ùå';

        // F√ºge Icon ein
        regionSpan.appendChild(icon);

        log(`‚úì Validierung-Icon erstellt: ${icon.textContent} (mydealz: ${actualCount}, Erwartet: ${expectedCount})`);
    }

    function setupPopupValidation(regionSpan, merchant, actualRegions, expectedRegions) {
        let observer = null;
        let validationDone = false;

        const validatePopup = () => {
            // Pr√ºfe ob bereits validiert
            if (validationDone) {
                log('Popup bereits validiert, √ºberspringe');
                return;
            }

            // Suche nach dem Popup (mit kurzer Verz√∂gerung f√ºr Rendering)
            setTimeout(() => {
                const popup = document.querySelector('section[role="dialog"].popover--visible .popover-body');
                if (!popup) {
                    log('‚ö† Popup nicht gefunden (noch nicht gerendert?)');
                    return;
                }

                // WICHTIG: Markiere als validiert SOFORT (verhindert mehrfache Ausf√ºhrung!)
                validationDone = true;

                // Extrahiere ORIGINAL mydealz-Regionen (ohne Script-modifizierten Inhalt)
                // Hole nur die ERSTEN Kinder-Spans (bevor Script eingreift)
                const popupContainer = popup.querySelector('span');
                if (!popupContainer) {
                    log('‚ö† Popup-Container nicht gefunden');
                    return;
                }

                // Z√§hle nur spans OHNE gelben Hintergrund (= Original mydealz)
                const allSpans = popupContainer.querySelectorAll('span');
                const regionsInPopup = Array.from(allSpans)
                    .filter(span => !span.style.backgroundColor || span.style.backgroundColor !== 'rgb(255, 243, 205)')
                    .map(span => normalizeRegionName(span.textContent.trim()))
                    .filter(r => r.length > 0);

                log(`Popup-Regionen gefunden (${regionsInPopup.length} ORIGINAL von mydealz): ${regionsInPopup.join(', ')}`);

                let wrongRegions = [];
                let missingRegions = [];

                // Wenn validRegions definiert ist, verwende detaillierte Validierung
                if (merchant.validRegions && merchant.validRegions.length > 0) {
                    log(`Erwartete Regionen (${merchant.validRegions.length}): ${merchant.validRegions.join(', ')}`);

                    // Spezialbehandlung f√ºr "andere": Z√§hle Vorkommen
                    const expectedAndereCount = merchant.validRegions.filter(r => r === 'andere').length;
                    const actualAndereCount = regionsInPopup.filter(r => r === 'andere').length;

                    // Finde falsche Regionen (ohne "andere"-Duplikate falsch zu markieren)
                    wrongRegions = regionsInPopup.filter(r => {
                        if (r === 'andere') {
                            // "andere" ist nur falsch wenn zu oft vorkommend
                            return false; // Sp√§ter pr√ºfen wir Anzahl separat
                        }
                        return !merchant.validRegions.includes(r);
                    });

                    // Wenn zu viele "andere": Markiere √ºberz√§hlige als falsch
                    if (actualAndereCount > expectedAndereCount) {
                        const extraAndere = actualAndereCount - expectedAndereCount;
                        log(`‚ö† ${extraAndere} "andere" zu viel (erwartet ${expectedAndereCount}, gefunden ${actualAndereCount})`);
                        // F√ºge "andere" extraAndere-mal zu wrongRegions hinzu
                        for (let i = 0; i < extraAndere; i++) {
                            wrongRegions.push('andere');
                        }
                    }

                    missingRegions = merchant.validRegions.filter(r => !regionsInPopup.includes(r));
                } else {
                    // Fallback: Nur Anzahl-basierte Validierung
                    log(`Keine validRegions definiert, verwende Anzahl-basierte Validierung`);
                    log(`Erwartet: ${expectedRegions} Regionen, Gefunden: ${actualRegions} (${regionsInPopup.length} im Popup)`);

                    // Wenn zu viele Regionen: Alle als "potenziell falsch" markieren (User muss pr√ºfen)
                    if (regionsInPopup.length > expectedRegions) {
                        const extraCount = regionsInPopup.length - expectedRegions;
                        log(`‚ö† ${extraCount} Region(en) zu viel - bitte manuell pr√ºfen welche falsch sind`);
                        // Markiere ALLE als "zu pr√ºfen" wenn keine validRegions Liste vorhanden
                        wrongRegions = []; // Keine spezifische Markierung ohne validRegions
                        missingRegions = [];
                    } else if (regionsInPopup.length < expectedRegions) {
                        const missingCount = expectedRegions - regionsInPopup.length;
                        log(`‚ö† ${missingCount} Region(en) fehlen`);
                    }
                }

                if (wrongRegions.length > 0 || missingRegions.length > 0 || regionsInPopup.length !== expectedRegions) {
                    log(`‚ö† Fehlerhafte Regionen gefunden!`);
                    if (wrongRegions.length > 0) {
                        log(`  Falsch (sollten nicht da sein): ${wrongRegions.join(', ')}`);
                    }
                    if (missingRegions.length > 0) {
                        log(`  Fehlen: ${missingRegions.join(', ')}`);
                    }

                    // Markiere falsche Regionen im Popup
                    highlightWrongRegionsInPopup(popup, wrongRegions, missingRegions, regionsInPopup.length, expectedRegions);
                } else {
                    log(`‚úì Alle Regionen korrekt`);
                }

                // Disconnect Observer nach Validierung (egal ob Fehler oder korrekt)
                if (observer) {
                    observer.disconnect();
                    observer = null;
                }
            }, 100); // 100ms Verz√∂gerung f√ºr Popup-Rendering
        };

        // Observer f√ºr DOM-√Ñnderungen (falls Popup dynamisch erscheint)
        observer = new MutationObserver((mutations) => {
            validatePopup();
        });

        // Beobachte body f√ºr Popup-Erscheinen
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Click-Handler auf regionSpan: Reaktiviere Validierung bei erneutem Klick
        regionSpan.addEventListener('click', (e) => {
            // Verhindere mehrfache Validierung nicht mehr - User k√∂nnte Popup mehrmals √∂ffnen
            validationDone = false;

            // Pr√ºfe sofort ob Popup schon da ist
            validatePopup();

            // Falls nicht, warte auf DOM-√Ñnderungen
            if (!observer) {
                observer = new MutationObserver((mutations) => {
                    validatePopup();
                });
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }

            log('‚úì Popup-Validation reaktiviert (User-Klick)');
        });

        // Initiale Pr√ºfung (falls Popup bereits offen beim Seitenload)
        validatePopup();

        log('‚úì Popup-Validation Observer gestartet');
    }

    function highlightWrongRegionsInPopup(popupBody, wrongRegions, missingRegions, actualCount, expectedCount) {
        // Erstelle farblich markierte Version des Popup-Texts
        const originalText = popupBody.textContent;
        const regions = originalText.split(',').map(r => r.trim());

        // L√∂sche vorhandenen Inhalt
        popupBody.innerHTML = '';

        // Erstelle Container f√ºr Regionen (inline, wie mydealz-Stil)
        const regionContainer = document.createElement('span');

        // F√ºr "andere": Z√§hle wie viele wir als falsch markieren sollen
        let andereMarkedCount = 0;
        const wrongAndereCount = wrongRegions.filter(r => r === 'andere').length;

        regions.forEach((region, index) => {
            const normalized = normalizeRegionName(region);
            let isWrong = false;

            // Spezialbehandlung f√ºr "andere": Nur X-mal als falsch markieren (wenn zu viele)
            if (normalized === 'andere') {
                if (wrongAndereCount > 0 && andereMarkedCount < wrongAndereCount) {
                    isWrong = true;
                    andereMarkedCount++;
                }
            } else {
                isWrong = wrongRegions.includes(normalized);
            }

            const span = document.createElement('span');
            span.textContent = region;

            if (isWrong) {
                // Rote Markierung f√ºr falsche Regionen
                span.style.cssText = `
                    background-color: #ff6b6b;
                    color: white;
                    padding: 2px 4px;
                    border-radius: 3px;
                    font-weight: bold;
                `;
                span.title = `‚ùå Sollte NICHT vorhanden sein!`;
            }

            regionContainer.appendChild(span);

            // F√ºge Komma hinzu (au√üer beim letzten Element)
            if (index < regions.length - 1) {
                regionContainer.appendChild(document.createTextNode(', '));
            }
        });

        // F√ºge fehlende Regionen inline hinzu (gelb markiert, mit Gro√üschreibung)
        if (missingRegions.length > 0) {
            // Kapitalisierungsfunktion f√ºr Bundesland-Namen
            const capitalizeRegion = (region) => {
                const mapping = {
                    'andere': 'Andere',
                    'berlin': 'Berlin',
                    'brandenburg': 'Brandenburg',
                    'bremen': 'Bremen',
                    'hamburg': 'Hamburg',
                    'hessen': 'Hessen',
                    'mecklenburg-vorpommern': 'Mecklenburg-Vorpommern',
                    'niedersachsen': 'Niedersachsen',
                    'nordrhein-westfalen': 'Nordrhein-Westfalen',
                    'rheinland-pfalz': 'Rheinland-Pfalz',
                    'saarland': 'Saarland',
                    'sachsen': 'Sachsen',
                    'sachsen-anhalt': 'Sachsen-Anhalt',
                    'schleswig-holstein': 'Schleswig-Holstein',
                    'th√ºringen': 'Th√ºringen',
                    'baden-w√ºrttemberg': 'Baden-W√ºrttemberg',
                    'bayern': 'Bayern'
                };
                return mapping[region] || region;
            };

            missingRegions.forEach((missingRegion) => {
                regionContainer.appendChild(document.createTextNode(', '));

                const missingSpan = document.createElement('span');
                missingSpan.textContent = capitalizeRegion(missingRegion);
                missingSpan.style.cssText = `
                    background-color: #fff3cd;
                    color: #856404;
                    padding: 2px 4px;
                    border-radius: 3px;
                    font-weight: bold;
                `;
                missingSpan.title = `‚ö† Fehlt in Deal-Konfiguration!`;

                regionContainer.appendChild(missingSpan);
            });
        }

        popupBody.appendChild(regionContainer);
        log('‚úì Popup-Inhalt mit Markierungen aktualisiert (inline-Stil)');
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    function init() {
        log('Script gestartet v2.0');

        // Registriere Tampermonkey Menu Command
        GM_registerMenuCommand('üìã H√§ndler-Meldungen kopieren', showHaendlerMenu);

        // Initiales Processing mit Verz√∂gerung (warte auf vollst√§ndiges Rendering)
        setTimeout(() => {
            processDeals();
            handleReportPage();
            validateRegionCount(); // Region-Validierung auf Detail-Seiten
        }, 500);

        // Debounced Version von processDeals (wartet 250ms nach letzter √Ñnderung)
        const debouncedProcessDeals = debounce(processDeals, 250);

        // Beobachte DOM-√Ñnderungen f√ºr dynamisch geladene Deals
        // Nur auf relevante Container fokussieren statt gesamtem body
        const observer = new MutationObserver((mutations) => {
            // Pr√ºfe ob wirklich Deal-relevante √Ñnderungen vorliegen
            const hasRelevantChanges = mutations.some(mutation => {
                // Pr√ºfe ob neue Nodes hinzugef√ºgt wurden
                if (mutation.addedNodes.length > 0) {
                    for (const node of mutation.addedNodes) {
                        if (node.nodeType === 1) {
                            // Pr√ºfe ob es ein Deal ist oder Deal-Container
                            if (node.classList && (node.classList.contains('thread') || node.querySelector('.thread'))) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            });

            if (hasRelevantChanges) {
                debouncedProcessDeals();
            }
        });

        // Beobachte nur den Haupt-Content-Bereich (spezifischer als document.body)
        const targetNode = document.querySelector('#main') || document.body;
        observer.observe(targetNode, {
            childList: true,
            subtree: true
        });

        // Beobachte URL-√Ñnderungen (f√ºr Single-Page-App Navigation)
        let lastUrl = location.href;
        new MutationObserver(() => {
            const currentUrl = location.href;
            if (currentUrl !== lastUrl) {
                lastUrl = currentUrl;
                log(`URL ge√§ndert: ${currentUrl}`);

                // Verarbeite Deals auf neuer Seite
                setTimeout(() => {
                    processDeals();
                    handleReportPage();
                    validateRegionCount(); // Region-Validierung auf Detail-Seiten
                }, 300);
            }
        }).observe(document.querySelector('title'), {
            childList: true,
            subtree: true
        });
    }

    // Starte Script nach DOM-Load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
